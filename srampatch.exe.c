//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    int32_t e0;
};

// ------------------- Function Prototypes --------------------

int32_t function_401000(void);
int32_t function_401010(int32_t a1);
int32_t function_401020(void);
int32_t function_401050(int32_t a1, int32_t a2, int32_t * a3, int32_t * a4);
int32_t function_4010e0(char * a1);
int32_t function_401100(int32_t a1, int32_t a2, int32_t a3);
int32_t function_401150(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6);
int32_t function_4011e0(int32_t a1, int32_t a2);
int32_t function_401230(int32_t a1, int32_t * a2);
int32_t function_401250(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_401290(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_4012d0(int32_t a1, int32_t a2, int32_t a3, int32_t a4);
int32_t function_401340(int32_t a1, uint32_t a2);
int32_t function_4014d0(int32_t a1, int32_t a2);
int32_t function_401520(int32_t a1, int32_t a2);
int32_t function_401570(uint32_t a1, int32_t a2, int32_t a3);
int32_t function_401660(int32_t a1, int32_t a2);
int32_t function_4016c0(int32_t a1, int32_t a2);
int32_t function_401720(int32_t a1, int32_t a2);
int32_t function_401810(int32_t a1, int32_t a2, int32_t a3);
int32_t function_4018c0(int32_t a1, int32_t a2);
int32_t function_401cea(int32_t a1);

// --------------------- Global Variables ---------------------

char * g1[6] = {
    "EEPROM_V",
    "FLASH_V",
    "SRAM_V",
    "SRAM_F_V",
    "FLASH1M_V",
    "FLASH512_V"
}; // 0x40a040
char * g2 = "\x03\x02\x01\x01\x02\x02"; // 0x40a058
int32_t g3; // 0x40a490
int32_t g4 = 16; // 0x40a530
char g5 = 0; // 0x40ac60
int32_t g6;
int32_t g7;
int32_t g8;

// ------------------------ Functions -------------------------

// Address range: 0x401000 - 0x40100d
int32_t function_401000(void) {
    // 0x401000
    return g5 & -16;
}

// Address range: 0x401010 - 0x40101a
int32_t function_401010(int32_t a1) {
    // 0x401010
    g5 = a1;
    int32_t v1; // 0x401010
    return v1 & -256 | a1 & 255;
}

// Address range: 0x401020 - 0x401043
int32_t function_401020(void) {
    // 0x401020
    return function_4010e0("Device :\n - Normal (default) : %d\n - F2A : %d\n - PRO : %d\n - TURBO : %d\n - EXTREM : %d\n - EZ : %d\n - EZ2 : %d\n - XG : %d\n - XROM : %d\n");
}

// Address range: 0x401050 - 0x4010dc
int32_t function_401050(int32_t a1, int32_t a2, int32_t * a3, int32_t * a4) {
    // 0x401050
    int32_t v1; // bp-16, 0x401050
    int32_t v2 = &v1; // 0x40105f
    *a3 = 0;
    int32_t v3 = 0;
    int32_t v4 = *(int32_t *)(4 * v3 + (int32_t)&g1); // 0x401070
    int32_t v5 = v4;
    int32_t v6 = v5 + 1; // 0x401085
    while (*(char *)v5 != 0) {
        // 0x401080
        v5 = v6;
        v6 = v5 + 1;
    }
    int32_t v7 = v5 - v4; // 0x401087
    *(int32_t *)(v2 - 4) = v7;
    *(int32_t *)(v2 - 8) = v4;
    *(int32_t *)(v2 - 12) = a2;
    *(int32_t *)(v2 - 16) = a1;
    int32_t result = function_4011e0((int32_t)&g8, (int32_t)&g8); // 0x40108f
    while (result == 0) {
        int32_t v8 = v3 + 1; // 0x40109b
        if (v8 >= 6) {
            // 0x4010a1
            return result;
        }
        v3 = v8;
        v4 = *(int32_t *)(4 * v3 + (int32_t)&g1);
        v5 = v4;
        v6 = v5 + 1;
        while (*(char *)v5 != 0) {
            // 0x401080
            v5 = v6;
            v6 = v5 + 1;
        }
        // 0x401087
        v7 = v5 - v4;
        *(int32_t *)(v2 - 4) = v7;
        *(int32_t *)(v2 - 8) = v4;
        *(int32_t *)(v2 - 12) = a2;
        *(int32_t *)(v2 - 16) = a1;
        result = function_4011e0((int32_t)&g8, (int32_t)&g8);
    }
    int32_t v9 = result + v7;
    unsigned char v10 = *(char *)v9; // 0x4010a6
    unsigned char v11 = *(char *)(v9 + 1); // 0x4010aa
    unsigned char v12 = *(char *)(v9 + 2); // 0x4010b5
    int32_t v13 = *(int32_t *)(v2 + 32); // 0x4010c4
    *(int32_t *)v13 = (int32_t)v12 - 0x14d0 + 10 * (10 * (int32_t)v10 + (int32_t)v11);
    unsigned char v14 = *(char *)(v3 + (int32_t)&g2); // 0x4010ca
    int32_t result2 = *(int32_t *)(v2 + 28); // 0x4010d1
    *(int32_t *)result2 = (int32_t)v14;
    return result2;
}

// Address range: 0x4010e0 - 0x4010f3
int32_t function_4010e0(char * a1) {
    // 0x4010e0
    int32_t v1; // 0x4010e0
    return _vprintf(a1, (int32_t)&v1);
}

// Address range: 0x401100 - 0x40114d
int32_t function_401100(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401100
    int32_t v1; // 0x401100
    int32_t v2; // 0x401100
    int32_t v3 = __wfopen(a3, "wb", v1, v2); // 0x40110c
    if (v3 == 0) {
        // 0x40111a
        return function_4010e0("Prob with the file : %s") & -256;
    }
    struct _IO_FILE * v4 = (struct _IO_FILE *)v3; // 0x401135
    _fwrite((int32_t *)a1, a2, 1, v4);
    return _fclose(v4) & -256 | 1;
}

// Address range: 0x401150 - 0x4011db
int32_t function_401150(int32_t * a1, int32_t * a2, int32_t a3, int32_t a4, int32_t a5, int32_t a6) {
    // 0x401150
    int32_t v1; // 0x401150
    int32_t v2; // 0x401150
    int32_t v3 = __wfopen(a3, "rb", v1, v2); // 0x40115f
    if (v3 == 0) {
        // 0x40116d
        return function_4010e0("Prob with the file : %s") & -256;
    }
    struct _IO_FILE * v4 = (struct _IO_FILE *)v3; // 0x401185
    int32_t v5 = 0; // 0x401190
    if (_fseek(v4, 0, 2) == 0) {
        // 0x401192
        *a2 = _ftell(v4);
        _fseek(v4, 0, 0);
        int32_t v6 = function_401cea(*a2); // 0x4011ab
        *a1 = v6;
        v5 = _fread((int32_t *)v6, 1, *a2, v4) == *a2;
    }
    // 0x4011cc
    return _fclose(v4) & -256 | v5;
}

// Address range: 0x4011e0 - 0x40122e
int32_t function_4011e0(int32_t a1, int32_t a2) {
    // 0x4011e0
    if (a1 == 0) {
        // 0x401225
        return 0;
    }
    // 0x4011e9
    int32_t v1; // bp-16, 0x4011e0
    int32_t v2 = &v1; // 0x4011ef
    int32_t * v3 = (int32_t *)(v2 + 32); // 0x4011f0
    int32_t * v4 = (int32_t *)(v2 + 28); // 0x4011f4
    int32_t * v5 = (int32_t *)(v2 - 4); // 0x4011ff
    int32_t * v6 = (int32_t *)(v2 - 8); // 0x401200
    int32_t * v7 = (int32_t *)(v2 - 12); // 0x401201
    bool v8; // 0x4011e0
    int32_t v9 = v8 ? -1 : 1;
    int32_t v10 = *v3; // 0x4011f0
    int32_t v11 = *v4; // 0x4011f4
    *v5 = a2 - v10;
    *v6 = (int32_t)*(char *)v11;
    *v7 = a1;
    int32_t * v12 = _memchr(&g8, (int32_t)&g8, (int32_t)&g8); // 0x401202
    int32_t v13 = a2; // 0x40120c
    int32_t result = 0; // 0x40120c
    if (v12 == NULL) {
      lab_0x401225:
        // 0x401225
        return result;
    }
    int32_t v14 = (int32_t)v12;
    int32_t v15 = v10; // 0x4011e0
    int32_t v16 = v11; // 0x4011e0
    result = v14;
    if (v15 == 0) {
        return result;
    }
    int32_t v17 = v14;
    char v18 = *(char *)v16; // 0x401214
    v15--;
    int32_t v19 = v17 + v9; // 0x401214
    v16 += v9;
    while (*(char *)v17 == v18) {
        // 0x40120e
        result = v14;
        if (v15 == 0) {
            return result;
        }
        v17 = v19;
        v18 = *(char *)v16;
        v15--;
        v19 = v17 + v9;
        v16 += v9;
    }
    // 0x401218
    v13 = v13 + a1 + -1 - v14;
    int32_t v20 = v14 + 1; // 0x401220
    int32_t v21 = *v3; // 0x4011f0
    int32_t v22 = *v4; // 0x4011f4
    *v5 = v13 - v21;
    *v6 = (int32_t)*(char *)v22;
    *v7 = v20;
    int32_t * v23 = _memchr(&g8, (int32_t)&g8, (int32_t)&g8); // 0x401202
    while (v23 != NULL) {
        // 0x40120e
        v14 = (int32_t)v23;
        v15 = v21;
        v16 = v22;
        result = v14;
        if (v15 == 0) {
            return result;
        }
        v17 = v14;
        v18 = *(char *)v16;
        v15--;
        v19 = v17 + v9;
        v16 += v9;
        while (*(char *)v17 == v18) {
            // 0x40120e
            result = v14;
            if (v15 == 0) {
                return result;
            }
            v17 = v19;
            v18 = *(char *)v16;
            v15--;
            v19 = v17 + v9;
            v16 += v9;
        }
        // 0x401218
        v13 = v13 + v20 + -1 - v14;
        v20 = v14 + 1;
        v21 = *v3;
        v22 = *v4;
        *v5 = v13 - v21;
        *v6 = (int32_t)*(char *)v22;
        *v7 = v20;
        v23 = _memchr(&g8, (int32_t)&g8, (int32_t)&g8);
    }
    // 0x401225
    return 0;
}

// Address range: 0x401230 - 0x401249
int32_t function_401230(int32_t a1, int32_t * a2) {
    int32_t v1 = 4 * a1; // 0x401234
    *a2 = *(int32_t *)(v1 + (int32_t)&g4);
    return *(int32_t *)(v1 + (int32_t)&g3);
}

// Address range: 0x401250 - 0x401282
int32_t function_401250(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t result = -1; // 0x401267
    if (*(int32_t *)(4 * a3 + (int32_t)&g3) != 0) {
        // 0x401269
        result = function_4011e0(a1, a2) - a1;
    }
    // 0x401281
    return result;
}

// Address range: 0x401290 - 0x4012ce
int32_t function_401290(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = 4 * a3; // 0x40129b
    int32_t v2 = *(int32_t *)(v1 + (int32_t)&g3); // 0x40129b
    if (a2 < 1 || v2 == 0) {
        // 0x4012ca
        return a3 & -256;
    }
    uint32_t v3 = *(int32_t *)(v1 + (int32_t)&g4); // 0x4012a8
    int32_t v4 = a2 + a1; // 0x4012b4
    uint32_t v5 = v3 / 4; // 0x4012b9
    __asm_rep_movsd_memcpy((char *)v4, (char *)v2, v5);
    bool v6; // 0x401290
    char * v7 = (char *)(v5 * (v6 ? -4 : 4) + v4); // 0x4012c3
    __asm_rep_movsb_memcpy(v7, v7, v3 & 3);
    return a1 & -256 | 1;
}

// Address range: 0x4012d0 - 0x401335
int32_t function_4012d0(int32_t a1, int32_t a2, int32_t a3, int32_t a4) {
    int32_t v1 = -1; // 0x4012ed
    if (*(int32_t *)(4 * a3 + (int32_t)&g3) != 0) {
        // 0x4012ef
        v1 = function_4011e0(a1, a2) - a1;
    }
    int32_t v2 = 4 * a4; // 0x401307
    int32_t v3 = *(int32_t *)(v2 + (int32_t)&g3); // 0x401307
    if (v1 < 1 || v3 == 0) {
        // 0x401330
        return v1 & -256;
    }
    uint32_t v4 = *(int32_t *)(v2 + (int32_t)&g4); // 0x401314
    int32_t v5 = v1 + a1; // 0x40131d
    uint32_t v6 = v4 / 4; // 0x40131f
    __asm_rep_movsd_memcpy((char *)v5, (char *)v3, v6);
    bool v7; // 0x4012d0
    char * v8 = (char *)(v6 * (v7 ? -4 : 4) + v5); // 0x401329
    __asm_rep_movsb_memcpy(v8, v8, v4 & 3);
    return v1 & -256 | 1;
}

// Address range: 0x401340 - 0x4014cc
int32_t function_401340(int32_t a1, uint32_t a2) {
    // 0x401340
    int32_t v1; // 0x401340
    int32_t v2 = function_401250(a1, a2, 0, v1); // 0x401353
    int32_t v3 = function_401250(a1, a2, 3, (int32_t)&g8); // 0x401362
    if (v2 < 1 || v3 < 1) {
        // 0x4014c2
        return function_4010e0("Motif for version V11x not found") & -256;
    }
    // 0x40137c
    int32_t v4; // bp-16, 0x401340
    int32_t v5 = function_401230(1, &v4); // 0x401383
    int32_t v6; // bp-20, 0x401340
    int32_t v7 = function_401230(2, &v6); // 0x401391
    int32_t v8; // bp-4, 0x401340
    int32_t v9 = function_401230(4, &v8); // 0x4013a3
    if (v5 == 0 || v7 == 0 || v9 == 0) {
        // 0x4014c2
        return v9 & -256;
    }
    // 0x4013c7
    *(char *)(v7 + 184) = (char)v3 + 33;
    *(char *)(v7 + 186) = (char)(v3 / 0x10000);
    int32_t v10 = v2 + a1; // 0x4013e8
    uint32_t v11 = v4 / 4; // 0x4013ed
    __asm_rep_movsd_memcpy((char *)v10, (char *)v5, v11);
    bool v12; // 0x401340
    int32_t v13 = v12 ? -4 : 4; // 0x4013f0
    int32_t v14 = a2 - 1; // 0x4013fb
    char * v15 = (char *)(v11 * v13 + v10); // 0x4013fc
    __asm_rep_movsb_memcpy(v15, v15, v4 & 3);
    uint32_t v16 = 256 - (v14 & 255) + v14; // 0x401410
    int32_t v17 = function_401cea(v6 + v16); // 0x40141a
    uint32_t v18 = a2 / 4; // 0x401425
    __asm_rep_movsd_memcpy((char *)v17, (char *)a1, v18);
    char * v19 = (char *)(v17 + v13 * v18); // 0x40143a
    __asm_rep_movsb_memcpy(v19, v19, a2 & 3);
    _free(&g8);
    int32_t v20 = v17 + v16;
    char v21 = *(char *)(v20 - 1); // 0x401445
    int32_t v22; // 0x401340
    if (v21 == -1) {
        // 0x40145c
        v22 = v3;
        goto lab_0x40145e;
    } else {
        // 0x401454
        v22 = v3 + 31;
        if (v21 != -51) {
            goto lab_0x40145e;
        } else {
            // 0x40145c
            v22 = v3;
            goto lab_0x40145e;
        }
    }
  lab_0x40145e:
    // 0x40145e
    *(char *)(v7 + 185) = (char)(v22 / 256);
    *(char *)(v9 + 5) = (char)(v16 / 256);
    *(char *)(v9 + 6) = (char)(v16 / 0x10000);
    uint32_t v23 = v8 / 4; // 0x401485
    int32_t v24 = v17 + v3; // 0x401488
    __asm_rep_movsd_memcpy((char *)v24, (char *)v9, v23);
    char * v25 = (char *)(v23 * v13 + v24); // 0x401491
    __asm_rep_movsb_memcpy(v25, v25, v8 & 3);
    uint32_t v26 = v6 / 4; // 0x40149f
    __asm_rep_movsd_memcpy((char *)v20, (char *)v7, v26);
    char * v27 = (char *)(v26 * v13 + v20); // 0x4014a9
    __asm_rep_movsb_memcpy(v27, v27, v6 & 3);
    return v6 & -256 | 1;
}

// Address range: 0x4014d0 - 0x401519
int32_t function_4014d0(int32_t a1, int32_t a2) {
    int32_t v1 = function_4012d0(a1, a2, 5, 7); // 0x4014e1
    int32_t v2 = function_4012d0(a1, a2, 6, 8); // 0x4014ee
    if ((char)v1 == 0 || (char)v2 == 0) {
        // 0x401504
        return function_4010e0("Motif for version V12x not found") & -256;
    }
    // 0x4014fe
    return v2 & -256 | 1;
}

// Address range: 0x401520 - 0x401569
int32_t function_401520(int32_t a1, int32_t a2) {
    int32_t v1 = function_4012d0(a1, a2, 27, 7); // 0x401531
    int32_t v2 = function_4012d0(a1, a2, 6, 8); // 0x40153e
    if ((char)v1 == 0 || (char)v2 == 0) {
        // 0x401554
        return function_4010e0("Motif for version V12x not found") & -256;
    }
    // 0x40154e
    return v2 & -256 | 1;
}

// Address range: 0x401570 - 0x4015d3
int32_t function_401570(uint32_t a1, int32_t a2, int32_t a3) {
    // 0x401570
    g6 = a1;
    if (a1 < 2) {
        // 0x40158a
        return function_401340(a2, a3);
    }
    // 0x4015c3
    return function_4010e0("Library version not known or not found") & -256;
}

// Address range: 0x401660 - 0x4016b3
int32_t function_401660(int32_t a1, int32_t a2) {
    int32_t v1 = function_4012d0(a1, a2, 17, 18); // 0x401671
    function_4012d0(a1, a2, 19, 20);
    function_4012d0(a1, a2, 21, 22);
    int32_t v2 = function_4012d0(a1, a2, 23, 22); // 0x40169e
    if ((char)v1 == 0) {
        // 0x4016a0
        v2 = function_4010e0("Motif for version V12x not found");
    }
    // 0x4016ad
    return v2 & -256 | v1 & 255;
}

// Address range: 0x4016c0 - 0x401713
int32_t function_4016c0(int32_t a1, int32_t a2) {
    int32_t v1 = function_4012d0(a1, a2, 24, 25); // 0x4016d1
    function_4012d0(a1, a2, 26, 20);
    function_4012d0(a1, a2, 21, 22);
    int32_t v2 = function_4012d0(a1, a2, 23, 22); // 0x4016fe
    if ((char)v1 == 0) {
        // 0x401700
        v2 = function_4010e0("Motif for version V13x not found");
    }
    // 0x40170d
    return v2 & -256 | v1 & 255;
}

// Address range: 0x401720 - 0x40180c
int32_t function_401720(int32_t a1, int32_t a2) {
    // 0x401720
    if ((char)function_401000() != -128) {
        // 0x40172d
        return function_4010e0("This version is not supported by this device") & -256;
    }
    // 0x40173f
    int32_t v1; // 0x401720
    uint32_t v2 = function_401250(a1, a2, 28, v1); // 0x40174e
    int32_t v3 = function_4012d0(a1, a2, 28, 34); // 0x40175b
    if (v2 >= 1) {
        int32_t v4 = v2 + a1;
        *(char *)(v4 + 26) = 0;
        *(char *)(v4 + 27) = 0;
    }
    int32_t v5 = function_4012d0(a1, a2, 29, 35); // 0x40177b
    int32_t v6 = function_4012d0(a1, a2, 30, 36); // 0x40178a
    uint32_t v7 = function_401250(a1, a2, 31, (int32_t)&g8); // 0x401797
    char v8 = 0; // 0x4017a3
    if (v7 >= 1) {
        // 0x4017a5
        v8 = function_401290(a1, a2, v7 - 6, 37);
    }
    // 0x4017b7
    function_4012d0(a1, a2, 32, 38);
    int32_t v9 = function_4012d0(a1, a2, 33, 39); // 0x4017c8
    if ((char)v3 == 0 || (char)v5 == 0 | (char)v6 == 0 || v8 == 0 || (char)v9 == 0) {
        // 0x4017f8
        return function_4010e0("Motif for version not found") & -256;
    }
    // 0x4017f3
    return v9 & -256 | 1;
}

// Address range: 0x401810 - 0x401886
int32_t function_401810(int32_t a1, int32_t a2, int32_t a3) {
    // 0x401810
    g7 = a1;
    return function_4010e0("Library version not known or not found") & -256;
}

// Address range: 0x4018c0 - 0x4019da
int32_t function_4018c0(int32_t a1, int32_t a2) {
    int32_t v1 = 0; // bp-12, 0x4018d5
    int32_t v2 = 0; // bp-16, 0x4018dd
    int32_t v3; // 0x4018c0
    int32_t v4 = function_401150(&v2, &v1, a1, v3, 0, 0); // 0x4018e5
    int32_t v5 = 0; // 0x4018ef
    int32_t v6; // bp-8, 0x4018c0
    int32_t v7; // 0x4018c0
    if ((char)v4 == 0) {
        goto lab_0x4019c2;
    } else {
        // 0x4018f5
        int32_t v8; // bp-4, 0x4018c0
        function_401050(v2, v1, &v8, &v6);
        function_4010e0("Backup type: %s, Version: %d\r\n");
        int32_t v9 = v8 - 2; // 0x401930
        if (v9 == 0) {
            // 0x401952
            if ((char)function_401000() == 80) {
                goto lab_0x40198e;
            } else {
                // 0x40195b
                if ((char)function_401000() == 64) {
                    goto lab_0x40198e;
                } else {
                    // 0x401964
                    if ((char)function_401000() == 96) {
                        goto lab_0x40198e;
                    } else {
                        // 0x40196d
                        if ((char)function_401000() == 112) {
                            goto lab_0x40198e;
                        } else {
                            // 0x401976
                            if ((char)function_401000() == -128) {
                                goto lab_0x40198e;
                            } else {
                                // 0x40197f
                                function_4010e0("This device don't need this rom be patched");
                                v5 = 0;
                                goto lab_0x4019c2;
                            }
                        }
                    }
                }
            }
        } else {
            // 0x401935
            v5 = 0;
            if (v9 != 1) {
                goto lab_0x4019c2;
            } else {
                // 0x40193c
                v7 = function_401570(v6, v2, v1);
                goto lab_0x4019a2;
            }
        }
    }
  lab_0x4019c2:;
    // 0x4019c2
    int32_t v10; // bp-20, 0x4018c0
    int32_t v11 = &v10; // 0x4018ea
    int32_t v12 = *(int32_t *)(v11 + 4); // 0x4019c2
    int32_t v13 = 0; // 0x4019c8
    if (v12 != 0) {
        // 0x4019ca
        *(int32_t *)(v11 - 4) = v12;
        _free(&g8);
        v13 = (int32_t)&g8 & -256;
    }
    // 0x4019d3
    return v13 | v5;
  lab_0x40198e:
    // 0x40198e
    v7 = function_401810(v6, v2, v1);
    goto lab_0x4019a2;
  lab_0x4019a2:;
    int32_t v14 = v7 & 255; // 0x4019a2
    v5 = v14;
    if ((char)v7 != 0) {
        // 0x4019ab
        function_401100(v2, v1, a2);
        v5 = v14;
    }
    goto lab_0x4019c2;
}

// Address range: 0x4019e0 - 0x401a37
int main(int argc, char ** argv) {
    if (argc <= 3) {
        // 0x4019ec
        function_4010e0("srampatch version : 2.3\nsrampatch device file_in file_out\nSample: srampatch 0 truc.gba trucout.gba\n");
        function_401020();
        return 1;
    }
    int32_t v1 = (int32_t)argv; // 0x401a08
    function_401010(_atol((char *)*(int32_t *)(v1 + 4)));
    int32_t v2 = *(int32_t *)(v1 + 8); // 0x401a1e
    return (char)function_4018c0(v2, *(int32_t *)(v1 + 12)) == 0;
}

// Address range: 0x401cea - 0x401cf8
int32_t function_401cea(int32_t a1) {
    // 0x401cea
    return __nh_malloc(a1, 1);
}

// --------------- Statically Linked Functions ----------------

// int32_t __nh_malloc(int32_t a1, int32_t a2);
// int32_t __wfopen(int32_t a1, char * a2, int32_t a3, int32_t a4);
// long int atol(const char * nptr);
// int fclose(FILE * stream);
// size_t fread(void * restrict ptr, size_t size, size_t n, FILE * restrict stream);
// void free(void * ptr);
// int fseek(FILE * stream, long int off, int whence);
// long int ftell(FILE * stream);
// size_t fwrite(const void * restrict ptr, size_t size, size_t n, FILE * restrict s);
// void * memchr(void * s, int c, size_t n);
// int vprintf(const char * restrict format, _G_va_list arg);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: microsoft linker (7.1)
// Detected language: C++
// Detected functions: 23
